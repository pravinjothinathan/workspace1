import java.io.DataInputStream;
import java.io.PrintStream;
import java.net.Socket;
import java.util.ArrayList;
import java.util.List;


public class Client extends Thread{

	static int timeStamp = 0;
	static List<Message> Queue = new ArrayList<Message>();
	
	//publis variables
	int Clock =0;
	Socket currSock;
	Client[] currClients;
	List<Info> ServerPort;
	DataInputStream disInputStream;
	PrintStream psOutputStream;
	Helper h;
	
	public Client(Socket clientSocket, Client[] clients) {
		// TODO Auto-generated constructor stub
		h = new Helper();
		h.Print("Entering client constructor");
		currSock = clientSocket;
		currClients = clients;
		h.Print("Client Creation : socket -"+clientSocket);
	}
	
	public Client(List<Info> servers,Client[] clients,int cVal)
	{
		h = new Helper();
		ServerPort = servers;
		currClients = clients;
		Clock = cVal;
	}
	
	@SuppressWarnings("deprecation")
	public void run()
	{
		String[] Files = null;
		int PID = h.GetPID();
		if(ServerPort!=null)
		{
			//Establishing Server Links
			Socket[] ServSock = new Socket[ServerPort.size()];
			DataInputStream [] disServerInputStream = new DataInputStream[ServerPort.size()];
			PrintStream [] psServerOutputStream = new PrintStream[ServerPort.size()];
			try
			{
				for(int i=0;i<ServerPort.size();i++)
				{
					Info ServInfo = ServerPort.get(i);
					ServSock[i] = new Socket(ServInfo.addr,ServInfo.portNo);
					disServerInputStream[i] = new DataInputStream(ServSock[i].getInputStream());
					psServerOutputStream[i] = new PrintStream(ServSock[i].getOutputStream());
				}
			}catch(Exception e)
			{
				h.Print("Crash! in File Server Socket and Stream Creation");
				e.printStackTrace();
			}
			//get the file list
			try
			{
				int no = h.GetRandomNo(ServerPort.size());
				h.Print("Rand no -"+no);
				psServerOutputStream[no].println("enquire");
				String s = disServerInputStream[no].readLine();
				h.Print("Files :"+ s);
				Files = s.split(" ");
				h.Print("Files in Server");
				h.Print(Files);
			}
			catch(Exception e)
			{
				h.Print("Crash! while enquiring the file");
				e.printStackTrace();
			}
			
			//Read Write and Lamport's Algorithm
			try
			{
				while(true)
				{
					h.Print("Queue Size"+Queue.size());
					Thread.sleep(Clock);
					if (Files!=null )
					{	
						int randFile = h.GetRandomNo(Files.length);
						int operation = h.GetRandomNo(2);
						timeStamp++;
						if(!inQueue(Files[randFile]))
						{
							SendRequest(Files[randFile],operation,PID);
							h.Print("My  : Message Sent");
						}
					}
					
					//checking whether top of the Queue is the request generated by this process and whether it has received all acks 
					if(Queue.size()>0)
					{
						for(int k=0;k<Queue.size();k++)
						{
							Message m = Queue.get(k);
							h.Print(m.FormlongMessage());
							if(m.processId==PID)
							{
								if(m.ackCount==m.reqCount)
								{
									h.Print("Ack count"+m.ackCount+" ant the Req count "+m.reqCount+"are equal");
									int ServRand = h.GetRandomNo(3);
									if(m.fileOperation==0)
									{
										psServerOutputStream[ServRand].println("read "+m.fileName);
										h.Print(disServerInputStream[ServRand].readLine());
									}
									else
									{
										for(int i=0;i<ServerPort.size();i++)
										{
											h.Print("File Write on Server i -"+i);
											psServerOutputStream[i].println("write "+m.fileName+" "+PID+" "+timeStamp);
											h.Print(disServerInputStream[i].readLine());
										}
									}
									
									h.Print("Release Sent");
									SendRelease(m);
									Queue.remove(k);
									h.Print("Server Queried and Queue Updated");
								}
							}
							else
							{
								if(m.ackCount==m.reqCount)
								{
									Queue.remove(k);
								}
							}
							}
					}
					
					//Thread.sleep(60000);
				}
				
			}catch(Exception e)
			{
				h.Print("Crash! Performing Read write operatins");
				e.printStackTrace();
			}
			
		}
		else
		{
			//main
			try
			{
				h.Print("Thread Started");
				disInputStream = new DataInputStream(currSock.getInputStream());
				h.Print("Input Stream Created");
				psOutputStream = new PrintStream(currSock.getOutputStream());
				h.Print("Output Stream Created");
				
				while(true)
				{
					h.Print("Queue Size"+Queue.size());
					for(int k=0;k<Queue.size();k++)
					{
						Message m = Queue.get(k);
						h.Print(m.FormlongMessage());
					}
					String s = disInputStream.readLine();
					h.Print("incoming message"+s+"from"+currSock.getPort()+currSock.getLocalAddress());
					if(s.startsWith("req"))
					{
						h.Print("Request message comes in");
						Message m = new Message(s);
						if(timeStamp<m.timeStamp)
							timeStamp = m.timeStamp;
						if(!CheckQueueForDependancey(m))
						{
							psOutputStream.println("ack "+m.FormMessage()+" "+timeStamp);
						}
						else
						{
							h.Print("Check for Dependency failed");
							Queue.add(0, m);
						}
					}
					else if(s.startsWith("ack"))
					{
						h.Print("ack received " +s);
						Message m = new Message(s);
						int tsSender = GetTimeStamp(s);
						if(timeStamp<tsSender)
							timeStamp = tsSender;
						UpdateAckinQueue(m);
					}
					else if(s.startsWith("rel"))
					{
						h.Print("Release received" +s);
						Message m = new Message(s);
						int tsSender = GetTimeStamp(s);
						if(timeStamp<tsSender)
							timeStamp = tsSender;
						UpdateRelinQueue(m);
					}
					else
					{
						h.Print("Un known msg format msg -"+s);
					}
				}
			}
			catch(Exception e)
			{
				e.printStackTrace();
			}
		}
	}

	private int GetTimeStamp(String s) {
		// TODO Auto-generated method stub
		String[] temp = s.split(" ");
		
		return Integer.parseInt(temp[5]);
	}

	private boolean inQueue(String string) {
		// TODO Auto-generated method stub
		for(int i=0;i<Queue.size();i++)
		{
			Message m = Queue.get(i);
			if(m.fileName.equals(string))
				return true;
		}
		return false;
	}

	private void UpdateRelinQueue(Message m) {
		// TODO Auto-generated method stub
		for(int i=0;i<Queue.size();i++)
		{
			Message msg = Queue.get(i);
			if(msg.compareignoringTimeStamp(m))
			{
				h.Print("m deleted from Queue");
				Queue.remove(i);
			}
		}
	}

	private void UpdateAckinQueue(Message m) {
		// TODO Auto-generated method stub
		for(int i=0;i<Queue.size();i++)
		{
			Message msg = Queue.get(i);
			if(msg.compare(m))
			{
				h.Print("added one to ack Queue");
				msg.addAckCount();
				
				//if(m.ackCount==msg.ackCount)
					//Queue.remove(i);
			}
		}
	}

	private boolean CheckQueueForDependancey(Message m) {
		// TODO Auto-generated method stub
		//boolean retVal = false;
		
		for(int i=0;i<Queue.size();i++)
		{
			Message msg = Queue.get(i);
			if(msg.fileName.equals(m.fileName))
			{
				if(msg.fileOperation==1 && m.fileOperation==0)
				{
					return true;
				}
				else if(msg.fileOperation==1 && m.fileOperation==1)
				{
					if(msg.timeStamp>m.timeStamp)
						return true;
					else if(msg.timeStamp==m.timeStamp)
					{
						if(msg.processId<m.processId)
							return true;
					}
				}
			}
		}
		return false;
	}
	
	private void SendRelease(Message m) {
		// TODO Auto-generated method stub
		String msg = "rel "+m.FormMessage()+" "+timeStamp;
		h.Print("Message to be sent -" + msg);
		for(int i=1;i<=currClients.length-1;i++)
		{
			if(currClients[i]!=null)
			{
				h.Print("Release Message to be sent to port "+currClients[i].currSock.getPort());
				currClients[i].psOutputStream.println(msg);
			}
		}
		
		h.Print("Release Message sent to :"+m.ackCount);
	}

	private void SendRequest(String file, int operation,int pid) {
		// TODO Auto-generated method stub
		Message msg = new Message(timeStamp,file,operation,pid);
		
		String strMsg = "req "+msg.FormMessage();
		h.Print("my : Message to be sent - "+ strMsg);
		for(int i=1;i<=currClients.length-1;i++)
		{
			if(currClients[i]!=null)
			{
				//currClients[i].psOutputStream.flush();
				h.Print("Request Message to be sent to port "+currClients[i].currSock.getPort());
				currClients[i].psOutputStream.println(strMsg);
				msg.addReqCount();
			}
		}
		h.Print("Request Message Sent to :"+msg.reqCount);
		Queue.add(msg);
	}

}
